<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Folding Plane — t1/t2 Crease</title>
<style>
  html,body{height:100%;margin:0;background:white;color:black;font:14px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{display:grid;grid-template-rows:auto 1fr auto;min-height:100%}
  header{padding:12px 16px;border-bottom:1px solid #ccc;background:white;position:sticky;top:0;z-index:2}
  header h1{font-size:16px;margin:0 0 4px 0;font-weight:700}
  header p{margin:0;color:#555}
  .controls{display:grid;gap:10px;grid-template-columns:repeat(3,minmax(200px,1fr));padding:12px 16px;border-bottom:1px solid #ccc}
  .control{background:#f8f8f8;padding:10px;border:1px solid #ddd;border-radius:8px}
  .control label{display:flex;justify-content:space-between;align-items:center;font-weight:600;margin-bottom:6px}
  .control .val{color:#0077cc;font-variant-numeric:tabular-nums}
  input[type=range]{width:100%}
  .canvasWrap{position:relative}
  canvas{display:block;width:100%;height:100%;background:white}
  .hud{position:absolute;inset:auto 16px 16px auto;background:rgba(255,255,255,0.8);color:#333;border:1px solid #ccc;padding:8px 10px;border-radius:10px;font-size:12px}
  .buttons{display:flex;gap:8px}
  button{cursor:pointer;border:1px solid #ccc;background:white;color:#333;border-radius:8px;padding:8px 10px;font-weight:600}
  button:hover{background:#eee}
  footer{display:flex;gap:12px;justify-content:space-between;align-items:center;padding:12px 16px;border-top:1px solid #ccc;color:#555}
  .kbd{padding:2px 6px;border:1px solid #ccc;border-bottom-width:2px;border-radius:6px;background:#f8f8f8;color:#333;font-weight:700}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Folding Plane — Crease from t1 (bottom) to t2 (top)</h1>
    <p>Drag to orbit · Scroll to zoom · Shift+Drag to pan. Export a PNG when ready.</p>
  </header>

  <section class="controls" id="controls">
    <div class="control">
      <label>t1 (bottom) <span class="val" id="vT1">0.5</span></label>
      <input id="t1" type="range" min="0.1" max="1.0" step="0.1" value="0.5"/>
    </div>
    <div class="control">
      <label>t2 (top) <span class="val" id="vT2">0.5</span></label>
      <input id="t2" type="range" min="0.1" max="1.0" step="0.1" value="0.5"/>
    </div>
    <div class="control">
      <label>Fold angle (°) <span class="val" id="vAng">0</span></label>
      <input id="ang" type="range" min="-180" max="180" step="1" value="0"/>
    </div>
  </section>

  <div class="canvasWrap">
    <canvas id="cv"></canvas>
    <div class="hud">
      <div class="buttons">
        <button id="reset">Reset View</button>
        <button id="save">Export PNG</button>
      </div>
    </div>
  </div>

  <footer>
    <div>Math & rendering: vanilla JS on <span class="kbd">&lt;canvas&gt;</span>. No libraries.</div>
    <div>Tip: set t1 ≈ t2 for a near-vertical hinge; vary angle for mountain/valley folds.</div>
  </footer>
</div>

<script>
(function(){
  const TAU = Math.PI*2;
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  function vec(x=0,y=0,z=0){return {x,y,z}}
  function add(a,b){return vec(a.x+b.x,a.y+b.y,a.z+b.z)}
  function sub(a,b){return vec(a.x-b.x,a.y-b.y,a.z-b.z)}
  function mul(a,s){return vec(a.x*s,a.y*s,a.z*s)}
  function dot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z}
  function cross(a,b){return vec(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x)}
  function len(a){return Math.hypot(a.x,a.y,a.z)}
  function norm(a){const L=len(a)||1;return mul(a,1/L)}
  function rotAroundAxis(p, A0, A1, ang){
    const u = norm(sub(A1,A0));
    const x = sub(p,A0);
    const cos = Math.cos(ang), sin = Math.sin(ang);
    const term1 = mul(x, cos);
    const term2 = mul(cross(u,x), sin);
    const term3 = mul(u, dot(u,x) * (1 - cos));
    return add(add(add(term1, term2), term3), A0);
  }

  const cam = {pos:vec(0,0,2.5),target:vec(0,0,0),up:vec(0,1,0),fov:50*Math.PI/180,near:.1,far:100,yaw:0.7,pitch:-0.3,dist:2.6};
  function look(){
    const cp = Math.cos(cam.pitch), sp = Math.sin(cam.pitch);
    const cy = Math.cos(cam.yaw),   sy = Math.sin(cam.yaw);
    const dir = vec(cy*cp, sp, sy*cp);
    cam.pos = add(cam.target, mul(dir, cam.dist));
  }
  function project(p, w, h){
    const zdir = norm(sub(cam.target, cam.pos));
    const xdir = norm(cross(zdir, cam.up));
    const ydir = cross(xdir, zdir);
    const rel = sub(p, cam.pos);
    const px = dot(rel, xdir);
    const py = dot(rel, ydir);
    const pz = dot(rel, zdir);
    const f = 1/Math.tan(cam.fov/2);
    const aspect = w/h;
    const sx = (f*px/(aspect*pz));
    const sy = (f*py/pz);
    return {x: w*(0.5+0.5*sx), y: h*(0.5-0.5*sy), z: pz};
  }

  const state = {W:1,H:1.4,t1:0.5,t2:0.5,ang:0};
  function makeMesh(){
    const {W,H} = state;
    const res = 36;
    const nx = res, ny = res;
    const verts=[],faces=[];
    for(let j=0;j<=ny;j++){
      for(let i=0;i<=nx;i++){
        const u = i/nx, v = j/ny;
        const x = (u-0.5)*W;
        const y = (v-0.5)*H;
        verts.push(vec(x,y,0));
      }
    }
    const idx=(i,j)=>j*(nx+1)+i;
    for(let j=0;j<ny;j++){
      for(let i=0;i<nx;i++){
        const a=idx(i,j), b=idx(i+1,j), c=idx(i+1,j+1), d=idx(i,j+1);
        faces.push([a,b,c]);
        faces.push([a,c,d]);
      }
    }
    return {verts,faces};
  }

  function foldMesh(mesh){
    const {verts,faces} = mesh;
    const {W,H,t1,t2,ang} = state;
    const pB = vec((t1-0.5)*W,(-0.5)*H,0);
    const pT = vec((t2-0.5)*W,(+0.5)*H,0);
    const axis2D = sub(vec(pT.x,pT.y,0), vec(pB.x,pB.y,0));
    const n2D = vec(-axis2D.y, axis2D.x, 0);
    const outVerts = verts.map(p=>{
      const side = (p.x - pB.x)*n2D.x + (p.y - pB.y)*n2D.y;
      return side>=0 ? rotAroundAxis(p,pB,pT,ang) : p;
    });
    return {verts:outVerts,faces,pB,pT};
  }

  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  let width=0,height=0; let mesh = makeMesh();

  function resize(){
    const dpr = Math.min(window.devicePixelRatio||1, 2);
    const rect = cv.getBoundingClientRect();
    width = Math.max(320, rect.width|0); height = Math.max(240, rect.height|0);
    cv.width = (width*dpr)|0; cv.height = (height*dpr)|0; ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function render(){
    resize(); look();
    ctx.clearRect(0,0,width,height);
    mesh = makeMesh();
    const folded = foldMesh(mesh);
    const P = folded.verts.map(p=>project(p,width,height));
    const tris = folded.faces.map((f)=>{
      const [a,b,c]=f; const z=(P[a].z+P[b].z+P[c].z)/3;
      return {a,b,c,z};
    }).sort((t1,t2)=>t2.z - t1.z);

    ctx.fillStyle = 'rgba(60,150,255,0.95)';
    ctx.strokeStyle = 'rgba(60,150,255,0.95)';
    for(const t of tris){
      const A=P[t.a], B=P[t.b], C=P[t.c];
      ctx.beginPath();
      ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.lineTo(C.x,C.y); ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    const k0 = project(folded.pB,width,height), k1 = project(folded.pT,width,height);
    ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.setLineDash([6,4]);
    ctx.beginPath(); ctx.moveTo(k0.x,k0.y); ctx.lineTo(k1.x,k1.y); ctx.stroke(); ctx.setLineDash([]);
  }

  const elT1 = document.getElementById('t1');
  const elT2 = document.getElementById('t2');
  const elAng = document.getElementById('ang');
  const vT1 = document.getElementById('vT1');
  const vT2 = document.getElementById('vT2');
  const vAng = document.getElementById('vAng');

  function updateVals(){
    state.t1 = +(+elT1.value).toFixed(1);
    state.t2 = +(+elT2.value).toFixed(1);
    state.ang = (+elAng.value) * Math.PI/180;
    vT1.textContent = state.t1.toFixed(1);
    vT2.textContent = state.t2.toFixed(1);
    vAng.textContent = (state.ang*180/Math.PI).toFixed(0);
    render();
  }
  [elT1,elT2,elAng].forEach(i=>i.addEventListener('input', updateVals));

  let dragging=false,lastX=0,lastY=0,panning=false;
  cv.addEventListener('mousedown',e=>{dragging=true;lastX=e.clientX;lastY=e.clientY;panning=e.shiftKey});
  window.addEventListener('mouseup',()=>dragging=false);
  window.addEventListener('mousemove',e=>{
    if(!dragging) return;
    const dx=(e.clientX-lastX)/200; const dy=(e.clientY-lastY)/200; lastX=e.clientX; lastY=e.clientY;
    if(panning){
      const scale = cam.dist*0.6;
      cam.target.x -= dx*scale; cam.target.y += dy*scale;
    } else {
      cam.yaw = (cam.yaw + dx) % TAU;
      cam.pitch = clamp(cam.pitch + dy, -1.3, 1.3);
    }
    render();
  });
  cv.addEventListener('wheel',e=>{e.preventDefault();cam.dist=clamp(cam.dist*(1+Math.sign(e.deltaY)*0.08),0.8,7);render();},{passive:false});

  document.getElementById('reset').addEventListener('click',()=>{cam.yaw=0.7; cam.pitch=-0.3; cam.dist=2.6; cam.target=vec(0,0,0); render();});
  document.getElementById('save').addEventListener('click',()=>{
    const a=document.createElement('a');a.download='folding_plane.png';a.href=cv.toDataURL('image/png');a.click();
  });
  const ro=new ResizeObserver(render);ro.observe(document.querySelector('.canvasWrap'));
  updateVals();
})();
</script>
</body>
</html>
